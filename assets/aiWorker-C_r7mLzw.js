var p=Object.defineProperty;var v=(h,l,f)=>l in h?p(h,l,{enumerable:!0,configurable:!0,writable:!0,value:f}):h[l]=f;var u=(h,l,f)=>v(h,typeof l!="symbol"?l+"":l,f);(function(){"use strict";class h{static extractConstraints(e){const t=[],s=e.getRevealedCells();for(const n of s){const i=e.getAdjacentCells(n.coordinates.x,n.coordinates.y),r=i.filter(c=>!c.isRevealed&&!c.isFlagged),o=i.filter(c=>c.isFlagged),a=n.adjacentMines-o.length;r.length>0&&a>=0&&t.push({centerCell:n.coordinates,requiredMines:a,affectedCells:r.map(c=>c.coordinates)})}return t}static findGuaranteedSafe(e){const t=this.extractConstraints(e),s=new Set;for(const n of t)if(n.requiredMines===0)for(const i of n.affectedCells)s.add(this.coordToString(i));return Array.from(s).map(n=>this.stringToCoord(n))}static findGuaranteedMines(e){const t=this.extractConstraints(e),s=new Set;for(const n of t)if(n.requiredMines===n.affectedCells.length&&n.requiredMines>0)for(const i of n.affectedCells)s.add(this.coordToString(i));return Array.from(s).map(n=>this.stringToCoord(n))}static findGuaranteedMoves(e){const t=this.extractConstraints(e),s=new Set,n=new Set;for(const i of t)if(i.requiredMines===0)for(const r of i.affectedCells)s.add(this.coordToString(r));else if(i.requiredMines===i.affectedCells.length&&i.requiredMines>0)for(const r of i.affectedCells)n.add(this.coordToString(r));for(let i=0;i<t.length;i++)for(let r=0;r<t.length;r++){if(i===r)continue;const o=t[i],a=t[r],c=new Set(o.affectedCells.map(this.coordToString)),d=new Set(a.affectedCells.map(this.coordToString));if(this.isSubset(c,d)){const M=Array.from(d).filter(g=>!c.has(g)),b=a.requiredMines-o.requiredMines;b===0?M.forEach(g=>s.add(g)):b===M.length&&b>0&&M.forEach(g=>n.add(g))}}return{safe:Array.from(s).map(i=>this.stringToCoord(i)),mines:Array.from(n).map(i=>this.stringToCoord(i))}}static validateConstraints(e){for(const t of e)if(t.requiredMines<0||t.requiredMines>t.affectedCells.length)return!1;return!0}static coordToString(e){return`${e.x},${e.y}`}static stringToCoord(e){const[t,s]=e.split(",").map(Number);return{x:t,y:s}}static isSubset(e,t){for(const s of e)if(!t.has(s))return!1;return!0}}class l{static calculateProbabilities(e){const t=new Map,s=h.extractConstraints(e),n=e.getUnrevealedCells().filter(a=>!a.isFlagged).map(a=>a.coordinates);if(n.length===0)return t;const i=new Set;s.forEach(a=>{a.affectedCells.forEach(c=>{i.add(this.coordToString(c))})});const r=n.filter(a=>i.has(this.coordToString(a))),o=n.filter(a=>!i.has(this.coordToString(a)));if(r.length>0&&s.length>0&&this.calculateConstrainedProbabilities(s,r).forEach((c,d)=>{t.set(d,c)}),o.length>0){const a=this.calculateUnconstrainedProbability(e,r.length,o.length);o.forEach(c=>{t.set(c,a)})}return t}static calculateConstrainedProbabilities(e,t){const s=new Map;t.forEach(r=>{s.set(r,0)});const n=this.generateValidAssignments(e,t);if(n.length===0)return t.forEach(o=>{s.set(o,.5)}),s;const i=new Map;return t.forEach(r=>{i.set(this.coordToString(r),0)}),n.forEach(r=>{Object.entries(r).forEach(([o,a])=>{a&&i.has(o)&&i.set(o,i.get(o)+1)})}),t.forEach(r=>{const o=this.coordToString(r),c=(i.get(o)||0)/n.length;s.set(r,c)}),s}static generateValidAssignments(e,t){const s=[],n=t.map(this.coordToString),i=Math.pow(2,t.length),r=Math.min(i,1e6);for(let o=0;o<r;o++){const a={};for(let c=0;c<t.length;c++){const d=(o&1<<c)!==0;a[n[c]]=d}this.isValidAssignment(a,e)&&s.push(a)}return s}static isValidAssignment(e,t){for(const s of t){let n=0;for(const i of s.affectedCells){const r=this.coordToString(i);e[r]===!0&&n++}if(n!==s.requiredMines)return!1}return!0}static calculateUnconstrainedProbability(e,t,s){if(s===0)return 0;const n=e.getMineCount(),i=e.getFlaggedCount(),r=e.getRevealedCells().filter(d=>d.hasMine).length,o=n-i-r,a=Math.min(o,Math.round(t*.2)),c=Math.max(0,o-a);return Math.min(1,c/s)}static calculateInformationGain(e,t){const s=t.getAdjacentCells(e.x,e.y),n=s.filter(a=>!a.isRevealed&&!a.isFlagged),i=s.filter(a=>a.isRevealed),r=n.length,o=i.length*.5;return r+o}static findLowestRiskCell(e){if(e.size===0)return null;let t=null,s=1;return e.forEach((n,i)=>{n<s&&(s=n,t=i)}),t}static handleEdgeCases(e,t){const s=new Map(t),{width:n,height:i}=e.getDimensions();return e.getRevealedCount()<n*i*.1&&s.forEach((o,a)=>{const c=(a.x===0||a.x===n-1)&&(a.y===0||a.y===i-1),d=a.x===0||a.x===n-1||a.y===0||a.y===i-1;c?s.set(a,o*.8):d&&s.set(a,o*.9)}),s}static coordToString(e){return`${e.x},${e.y}`}}class f{static analyzeBoard(e){const t=h.findGuaranteedMoves(e),s=l.calculateProbabilities(e),n=l.handleEdgeCases(e,s),i=this.getBestMove(e,t,n),r=this.calculateConfidence(t,n);return{guaranteedSafe:t.safe,guaranteedMines:t.mines,probabilities:n,recommendedMove:(i==null?void 0:i.coordinate)||null,confidence:r}}static getBestMove(e,t,s){return t.safe.length>0?{coordinate:this.selectBestGuaranteedSafe(e,t.safe),probability:0,priority:1e3,reasoning:"Guaranteed safe move"}:s.size>0?this.selectBestProbabilisticMove(e,s):null}static selectBestGuaranteedSafe(e,t){if(t.length===1)return t[0];let s=t[0],n=l.calculateInformationGain(s,e);for(let i=1;i<t.length;i++){const r=l.calculateInformationGain(t[i],e);r>n&&(n=r,s=t[i])}return s}static selectBestProbabilisticMove(e,t){const s=[];return t.forEach((n,i)=>{const r=l.calculateInformationGain(i,e),o=this.calculateMovePriority(n,r);s.push({coordinate:i,probability:n,priority:o,reasoning:this.generateMoveReasoning(n)})}),s.length===0?null:(s.sort((n,i)=>i.priority-n.priority),s[0])}static calculateMovePriority(e,t){const s=(1-e)*100,n=t*10;return s*.7+n*.3}static generateMoveReasoning(e){return e===0?"Guaranteed safe move":e<.1?`Very low risk (${Math.round(e*100)}% mine probability)`:e<.3?`Low risk (${Math.round(e*100)}% mine probability)`:e<.5?`Moderate risk (${Math.round(e*100)}% mine probability)`:e<.7?`High risk (${Math.round(e*100)}% mine probability)`:`Very high risk (${Math.round(e*100)}% mine probability)`}static calculateConfidence(e,t){if(e.safe.length>0||e.mines.length>0)return .9;if(t.size>0){const s=Array.from(t.values()),n=Math.min(...s),r=Math.max(...s)-n;return r>.3?.7:r>.1?.5:.3}return .1}static getTopMoves(e,t=3){const s=h.findGuaranteedMoves(e),n=l.calculateProbabilities(e),i=l.handleEdgeCases(e,n),r=[];return s.safe.forEach(o=>{r.push({coordinate:o,probability:0,priority:1e3,reasoning:"Guaranteed safe move"})}),i.forEach((o,a)=>{const c=l.calculateInformationGain(a,e),d=this.calculateMovePriority(o,c);r.push({coordinate:a,probability:o,priority:d,reasoning:this.generateMoveReasoning(o)})}),r.sort((o,a)=>a.priority-o.priority),r.slice(0,t)}static hasSolvableMoves(e){return h.findGuaranteedMoves(e).safe.length>0}static getFallbackMove(e){const t=l.calculateProbabilities(e);return t.size===0?null:l.findLowestRiskCell(t)}static isValidMove(e,t){const s=t.getCell(e.x,e.y);return s!==null&&!s.isRevealed&&!s.isFlagged}static analyzeCellRisk(e,t){const s=h.findGuaranteedMoves(t),n=l.calculateProbabilities(t),i=s.safe.some(c=>c.x===e.x&&c.y===e.y),r=s.mines.some(c=>c.x===e.x&&c.y===e.y),o=n.get(e)||.5;let a;return i?a="Guaranteed safe by constraint analysis":r?a="Guaranteed mine by constraint analysis":a=this.generateMoveReasoning(o),{probability:o,reasoning:a,isGuaranteedSafe:i,isGuaranteedMine:r}}}class y{constructor(e,t,s){u(this,"board");u(this,"width");u(this,"height");u(this,"mineCount");this.width=e,this.height=t,this.mineCount=s,this.board=this.initializeBoard()}initializeBoard(){const e=[];for(let t=0;t<this.height;t++){e[t]=[];for(let s=0;s<this.width;s++)e[t][s]={hasMine:!1,isRevealed:!1,isFlagged:!1,adjacentMines:0,coordinates:{x:s,y:t}}}return e}getCell(e,t){return this.isValidCoordinate(e,t)?this.board[t][e]:null}getBoard(){return this.board}isValidCoordinate(e,t){return e>=0&&e<this.width&&t>=0&&t<this.height}getAdjacentCells(e,t){const s=[];for(let n=-1;n<=1;n++)for(let i=-1;i<=1;i++){if(i===0&&n===0)continue;const r=e+i,o=t+n;this.isValidCoordinate(r,o)&&s.push(this.board[o][r])}return s}getAdjacentCoordinates(e,t){const s=[];for(let n=-1;n<=1;n++)for(let i=-1;i<=1;i++){if(i===0&&n===0)continue;const r=e+i,o=t+n;this.isValidCoordinate(r,o)&&s.push({x:r,y:o})}return s}placeMines(e){this.clearMines();for(const t of e)this.isValidCoordinate(t.x,t.y)&&(this.board[t.y][t.x].hasMine=!0);this.calculateAdjacentMines()}clearMines(){for(let e=0;e<this.height;e++)for(let t=0;t<this.width;t++)this.board[e][t].hasMine=!1,this.board[e][t].adjacentMines=0}calculateAdjacentMines(){for(let e=0;e<this.height;e++)for(let t=0;t<this.width;t++)if(!this.board[e][t].hasMine){const s=this.getAdjacentCells(t,e);this.board[e][t].adjacentMines=s.filter(n=>n.hasMine).length}}revealCell(e,t){const s=this.getCell(e,t);return!s||s.isRevealed||s.isFlagged?!1:(s.isRevealed=!0,!0)}toggleFlag(e,t){const s=this.getCell(e,t);return!s||s.isRevealed?!1:(s.isFlagged=!s.isFlagged,!0)}getUnrevealedCells(){const e=[];for(let t=0;t<this.height;t++)for(let s=0;s<this.width;s++)this.board[t][s].isRevealed||e.push(this.board[t][s]);return e}getRevealedCells(){const e=[];for(let t=0;t<this.height;t++)for(let s=0;s<this.width;s++)this.board[t][s].isRevealed&&e.push(this.board[t][s]);return e}getFlaggedCells(){const e=[];for(let t=0;t<this.height;t++)for(let s=0;s<this.width;s++)this.board[t][s].isFlagged&&e.push(this.board[t][s]);return e}getMineCells(){const e=[];for(let t=0;t<this.height;t++)for(let s=0;s<this.width;s++)this.board[t][s].hasMine&&e.push(this.board[t][s]);return e}getSafeCells(){const e=[];for(let t=0;t<this.height;t++)for(let s=0;s<this.width;s++)this.board[t][s].hasMine||e.push(this.board[t][s]);return e}areAllSafeCellsRevealed(){return this.getSafeCells().every(t=>t.isRevealed)}getDimensions(){return{width:this.width,height:this.height}}getMineCount(){return this.mineCount}getRevealedCount(){return this.getRevealedCells().length}getFlaggedCount(){return this.getFlaggedCells().length}reset(){for(let e=0;e<this.height;e++)for(let t=0;t<this.width;t++)this.board[e][t].isRevealed=!1,this.board[e][t].isFlagged=!1}}class C{constructor(){u(this,"performanceMetrics",new Map);self.addEventListener("message",this.handleMessage.bind(this)),this.postMessage({id:"init",type:"WORKER_READY",payload:{timestamp:Date.now()}})}handleMessage(e){const{id:t,type:s,payload:n}=e.data;try{switch(this.startPerformanceTracking(t),s){case"ANALYZE_BOARD":this.analyzeBoardAsync(t,n);break;case"CALCULATE_PROBABILITIES":this.calculateProbabilitiesAsync(t,n);break;case"FIND_BEST_MOVE":this.findBestMoveAsync(t,n);break;default:this.postError(t,`Unknown message type: ${s}`)}}catch(i){this.postError(t,i instanceof Error?i.message:"Unknown error")}}async analyzeBoardAsync(e,t){try{const s=this.reconstructGameBoard(t.boardData),n=await this.performAnalysisWithTimeout(s,5e3);this.endPerformanceTracking(e),this.postMessage({id:e,type:"ANALYSIS_COMPLETE",payload:{analysis:this.serializeAnalysis(n),performance:this.performanceMetrics.get(e)}})}catch(s){this.postError(e,s instanceof Error?s.message:"Analysis failed")}}async calculateProbabilitiesAsync(e,t){try{const s=this.reconstructGameBoard(t.boardData),n=f.analyzeBoard(s),i=this.serializeProbabilities(n.probabilities);this.endPerformanceTracking(e),this.postMessage({id:e,type:"ANALYSIS_COMPLETE",payload:{probabilities:i,performance:this.performanceMetrics.get(e)}})}catch(s){this.postError(e,s instanceof Error?s.message:"Probability calculation failed")}}async findBestMoveAsync(e,t){try{const s=this.reconstructGameBoard(t.boardData),n=f.analyzeBoard(s);this.endPerformanceTracking(e),this.postMessage({id:e,type:"ANALYSIS_COMPLETE",payload:{recommendedMove:n.recommendedMove,confidence:n.confidence,performance:this.performanceMetrics.get(e)}})}catch(s){this.postError(e,s instanceof Error?s.message:"Best move calculation failed")}}async performAnalysisWithTimeout(e,t){return new Promise((s,n)=>{const i=setTimeout(()=>{n(new Error("Analysis timeout"))},t);try{const r=f.analyzeBoard(e);clearTimeout(i),s(r)}catch(r){clearTimeout(i),n(r)}})}reconstructGameBoard(e){var r;const t=e.length,s=((r=e[0])==null?void 0:r.length)||0,n=e.flat().filter(o=>o.hasMine).length,i=new y(s,t,n);for(let o=0;o<t;o++)for(let a=0;a<s;a++){const c=e[o][a],d=i.getCell(a,o);d&&(d.hasMine=c.hasMine,d.isRevealed=c.isRevealed,d.isFlagged=c.isFlagged,d.adjacentMines=c.adjacentMines)}return i}serializeAnalysis(e){return{guaranteedSafe:e.guaranteedSafe,guaranteedMines:e.guaranteedMines,probabilities:this.serializeProbabilities(e.probabilities),recommendedMove:e.recommendedMove,confidence:e.confidence}}serializeProbabilities(e){return Array.from(e.entries())}startPerformanceTracking(e){const t={startTime:performance.now(),endTime:0,duration:0};"memory"in performance&&(t.memoryUsage=performance.memory.usedJSHeapSize),this.performanceMetrics.set(e,t)}endPerformanceTracking(e){const t=this.performanceMetrics.get(e);t&&(t.endTime=performance.now(),t.duration=t.endTime-t.startTime)}postMessage(e){self.postMessage(e)}postError(e,t){this.endPerformanceTracking(e),this.postMessage({id:e,type:"ERROR",payload:{error:t,performance:this.performanceMetrics.get(e)}})}}new C})();
