{"version":3,"file":"aiWorker-C_r7mLzw.js","sources":["../src/ai/ConstraintSolver.ts","../src/ai/ProbabilityCalculator.ts","../src/ai/HintEngine.ts","../src/models/GameBoard.ts","../src/workers/aiWorker.ts"],"sourcesContent":["import { Coordinate, Constraint, Cell } from '../types/index';\nimport { GameBoard } from '../models/GameBoard';\n\n/**\n * ConstraintSolver uses logical deduction to identify guaranteed safe cells and mines\n * based on revealed cell constraints\n */\nexport class ConstraintSolver {\n  /**\n   * Extract constraints from all revealed cells on the board\n   * A constraint represents a revealed cell with its adjacent mine count\n   * and the set of unrevealed adjacent cells\n   */\n  static extractConstraints(gameBoard: GameBoard): Constraint[] {\n    const constraints: Constraint[] = [];\n    const revealedCells = gameBoard.getRevealedCells();\n\n    for (const cell of revealedCells) {\n      const adjacentCells = gameBoard.getAdjacentCells(\n        cell.coordinates.x,\n        cell.coordinates.y\n      );\n\n      // Get unrevealed adjacent cells (excluding flagged cells)\n      const unrevealedAdjacent = adjacentCells.filter(\n        (c: Cell) => !c.isRevealed && !c.isFlagged\n      );\n\n      // Count already flagged adjacent cells\n      const flaggedAdjacent = adjacentCells.filter((c: Cell) => c.isFlagged);\n\n      // Calculate remaining mines needed in unrevealed cells\n      const remainingMines = cell.adjacentMines - flaggedAdjacent.length;\n\n      // Only create constraint if there are unrevealed cells and remaining mines to find\n      if (unrevealedAdjacent.length > 0 && remainingMines >= 0) {\n        constraints.push({\n          centerCell: cell.coordinates,\n          requiredMines: remainingMines,\n          affectedCells: unrevealedAdjacent.map((c: Cell) => c.coordinates)\n        });\n      }\n    }\n\n    return constraints;\n  }\n\n  /**\n   * Find cells that are guaranteed to be safe based on constraint analysis\n   */\n  static findGuaranteedSafe(gameBoard: GameBoard): Coordinate[] {\n    const constraints = this.extractConstraints(gameBoard);\n    const guaranteedSafe: Set<string> = new Set();\n\n    for (const constraint of constraints) {\n      // If required mines is 0, all affected cells are safe\n      if (constraint.requiredMines === 0) {\n        for (const coord of constraint.affectedCells) {\n          guaranteedSafe.add(this.coordToString(coord));\n        }\n      }\n    }\n\n    // Convert back to coordinates\n    return Array.from(guaranteedSafe).map(s => this.stringToCoord(s));\n  }\n\n  /**\n   * Find cells that are guaranteed to contain mines based on constraint analysis\n   */\n  static findGuaranteedMines(gameBoard: GameBoard): Coordinate[] {\n    const constraints = this.extractConstraints(gameBoard);\n    const guaranteedMines: Set<string> = new Set();\n\n    for (const constraint of constraints) {\n      // If required mines equals number of affected cells, all are mines\n      if (\n        constraint.requiredMines === constraint.affectedCells.length &&\n        constraint.requiredMines > 0\n      ) {\n        for (const coord of constraint.affectedCells) {\n          guaranteedMines.add(this.coordToString(coord));\n        }\n      }\n    }\n\n    return Array.from(guaranteedMines).map(s => this.stringToCoord(s));\n  }\n\n  /**\n   * Find all guaranteed moves using advanced constraint satisfaction\n   * This method applies subset and superset deduction rules\n   */\n  static findGuaranteedMoves(gameBoard: GameBoard): {\n    safe: Coordinate[];\n    mines: Coordinate[];\n  } {\n    const constraints = this.extractConstraints(gameBoard);\n    const guaranteedSafe: Set<string> = new Set();\n    const guaranteedMines: Set<string> = new Set();\n\n    // Apply simple rules first\n    for (const constraint of constraints) {\n      if (constraint.requiredMines === 0) {\n        // All affected cells are safe\n        for (const coord of constraint.affectedCells) {\n          guaranteedSafe.add(this.coordToString(coord));\n        }\n      } else if (\n        constraint.requiredMines === constraint.affectedCells.length &&\n        constraint.requiredMines > 0\n      ) {\n        // All affected cells are mines\n        for (const coord of constraint.affectedCells) {\n          guaranteedMines.add(this.coordToString(coord));\n        }\n      }\n    }\n\n    // Apply subset/superset deduction\n    for (let i = 0; i < constraints.length; i++) {\n      for (let j = 0; j < constraints.length; j++) {\n        if (i === j) continue;\n\n        const c1 = constraints[i];\n        const c2 = constraints[j];\n\n        // Check if c1's affected cells are a subset of c2's\n        const c1Set = new Set(c1.affectedCells.map(this.coordToString));\n        const c2Set = new Set(c2.affectedCells.map(this.coordToString));\n\n        if (this.isSubset(c1Set, c2Set)) {\n          // c1 is subset of c2\n          // Cells in c2 but not in c1\n          const difference = Array.from(c2Set).filter(s => !c1Set.has(s));\n          const mineDifference = c2.requiredMines - c1.requiredMines;\n\n          if (mineDifference === 0) {\n            // All cells in difference are safe\n            difference.forEach(s => guaranteedSafe.add(s));\n          } else if (mineDifference === difference.length && mineDifference > 0) {\n            // All cells in difference are mines\n            difference.forEach(s => guaranteedMines.add(s));\n          }\n        }\n      }\n    }\n\n    return {\n      safe: Array.from(guaranteedSafe).map(s => this.stringToCoord(s)),\n      mines: Array.from(guaranteedMines).map(s => this.stringToCoord(s))\n    };\n  }\n\n  /**\n   * Validate that constraints are consistent (no contradictions)\n   */\n  static validateConstraints(constraints: Constraint[]): boolean {\n    // Check for basic contradictions\n    for (const constraint of constraints) {\n      // Required mines cannot be negative\n      if (constraint.requiredMines < 0) {\n        return false;\n      }\n\n      // Required mines cannot exceed affected cells\n      if (constraint.requiredMines > constraint.affectedCells.length) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Helper: Convert coordinate to string for Set operations\n   */\n  private static coordToString(coord: Coordinate): string {\n    return `${coord.x},${coord.y}`;\n  }\n\n  /**\n   * Helper: Convert string back to coordinate\n   */\n  private static stringToCoord(str: string): Coordinate {\n    const [x, y] = str.split(',').map(Number);\n    return { x, y };\n  }\n\n  /**\n   * Helper: Check if set1 is a subset of set2\n   */\n  private static isSubset<T>(set1: Set<T>, set2: Set<T>): boolean {\n    for (const item of set1) {\n      if (!set2.has(item)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n","import { Coordinate, Constraint, Cell } from '../types/index';\nimport { GameBoard } from '../models/GameBoard';\nimport { ConstraintSolver } from './ConstraintSolver';\n\n/**\n * Configuration for mine assignment in constraint satisfaction\n */\ninterface MineAssignment {\n  [cellKey: string]: boolean; // true = mine, false = safe\n}\n\n/**\n * ProbabilityCalculator computes mine probabilities for uncertain scenarios\n * using Bayesian inference and combinatorial analysis\n */\nexport class ProbabilityCalculator {\n  /**\n   * Calculate mine probabilities for all unrevealed cells\n   */\n  static calculateProbabilities(\n    gameBoard: GameBoard\n  ): Map<Coordinate, number> {\n    const probabilities = new Map<Coordinate, number>();\n    const constraints = ConstraintSolver.extractConstraints(gameBoard);\n    const unrevealedCells = gameBoard.getUnrevealedCells()\n      .filter((cell: Cell) => !cell.isFlagged)\n      .map((cell: Cell) => cell.coordinates);\n\n    if (unrevealedCells.length === 0) {\n      return probabilities;\n    }\n\n    // Get cells that are part of constraints\n    const constrainedCells = new Set<string>();\n    constraints.forEach(constraint => {\n      constraint.affectedCells.forEach(coord => {\n        constrainedCells.add(this.coordToString(coord));\n      });\n    });\n\n    // Separate constrained and unconstrained cells\n    const constrainedCoords = unrevealedCells.filter((coord: Coordinate) =>\n      constrainedCells.has(this.coordToString(coord))\n    );\n    const unconstrainedCoords = unrevealedCells.filter((coord: Coordinate) =>\n      !constrainedCells.has(this.coordToString(coord))\n    );\n\n    // Calculate probabilities for constrained cells using CSP\n    if (constrainedCoords.length > 0 && constraints.length > 0) {\n      const constrainedProbs = this.calculateConstrainedProbabilities(\n        constraints,\n        constrainedCoords\n      );\n      constrainedProbs.forEach((prob, coord) => {\n        probabilities.set(coord, prob);\n      });\n    }\n\n    // Calculate probabilities for unconstrained cells\n    if (unconstrainedCoords.length > 0) {\n      const unconstrainedProb = this.calculateUnconstrainedProbability(\n        gameBoard,\n        constrainedCoords.length,\n        unconstrainedCoords.length\n      );\n      \n      unconstrainedCoords.forEach((coord: Coordinate) => {\n        probabilities.set(coord, unconstrainedProb);\n      });\n    }\n\n    return probabilities;\n  }\n\n  /**\n   * Calculate probabilities for cells involved in constraints using CSP solving\n   */\n  private static calculateConstrainedProbabilities(\n    constraints: Constraint[],\n    constrainedCells: Coordinate[]\n  ): Map<Coordinate, number> {\n    const probabilities = new Map<Coordinate, number>();\n    \n    // Initialize all probabilities to 0\n    constrainedCells.forEach(coord => {\n      probabilities.set(coord, 0);\n    });\n\n    // Generate all valid mine assignments\n    const validAssignments = this.generateValidAssignments(\n      constraints,\n      constrainedCells\n    );\n\n    if (validAssignments.length === 0) {\n      // No valid assignments - return uniform probability\n      const uniformProb = 0.5;\n      constrainedCells.forEach(coord => {\n        probabilities.set(coord, uniformProb);\n      });\n      return probabilities;\n    }\n\n    // Count how many times each cell is a mine across all valid assignments\n    const mineCounts = new Map<string, number>();\n    constrainedCells.forEach(coord => {\n      mineCounts.set(this.coordToString(coord), 0);\n    });\n\n    validAssignments.forEach(assignment => {\n      Object.entries(assignment).forEach(([cellKey, isMine]) => {\n        if (isMine && mineCounts.has(cellKey)) {\n          mineCounts.set(cellKey, mineCounts.get(cellKey)! + 1);\n        }\n      });\n    });\n\n    // Calculate probabilities as frequency of being a mine\n    constrainedCells.forEach(coord => {\n      const cellKey = this.coordToString(coord);\n      const mineCount = mineCounts.get(cellKey) || 0;\n      const probability = mineCount / validAssignments.length;\n      probabilities.set(coord, probability);\n    });\n\n    return probabilities;\n  }\n\n  /**\n   * Generate all valid mine assignments that satisfy the constraints\n   */\n  private static generateValidAssignments(\n    constraints: Constraint[],\n    cells: Coordinate[]\n  ): MineAssignment[] {\n    const validAssignments: MineAssignment[] = [];\n    const cellKeys = cells.map(this.coordToString);\n    \n    // Generate all possible assignments (2^n combinations)\n    const totalCombinations = Math.pow(2, cells.length);\n    \n    // Limit combinations for performance (max 20 cells = 1M combinations)\n    const maxCombinations = Math.min(totalCombinations, 1000000);\n    \n    for (let i = 0; i < maxCombinations; i++) {\n      const assignment: MineAssignment = {};\n      \n      // Convert binary representation to mine assignment\n      for (let j = 0; j < cells.length; j++) {\n        const isMine = (i & (1 << j)) !== 0;\n        assignment[cellKeys[j]] = isMine;\n      }\n      \n      // Check if this assignment satisfies all constraints\n      if (this.isValidAssignment(assignment, constraints)) {\n        validAssignments.push(assignment);\n      }\n    }\n    \n    return validAssignments;\n  }\n\n  /**\n   * Check if a mine assignment satisfies all constraints\n   */\n  private static isValidAssignment(\n    assignment: MineAssignment,\n    constraints: Constraint[]\n  ): boolean {\n    for (const constraint of constraints) {\n      let mineCount = 0;\n      \n      for (const coord of constraint.affectedCells) {\n        const cellKey = this.coordToString(coord);\n        if (assignment[cellKey] === true) {\n          mineCount++;\n        }\n      }\n      \n      if (mineCount !== constraint.requiredMines) {\n        return false;\n      }\n    }\n    \n    return true;\n  }\n\n  /**\n   * Calculate probability for unconstrained cells based on remaining mines\n   */\n  private static calculateUnconstrainedProbability(\n    gameBoard: GameBoard,\n    constrainedCellCount: number,\n    unconstrainedCellCount: number\n  ): number {\n    if (unconstrainedCellCount === 0) {\n      return 0;\n    }\n\n    // Calculate remaining mines\n    const totalMines = gameBoard.getMineCount();\n    const flaggedCount = gameBoard.getFlaggedCount();\n    const revealedMines = gameBoard.getRevealedCells()\n      .filter((cell: Cell) => cell.hasMine).length;\n    \n    const remainingMines = totalMines - flaggedCount - revealedMines;\n    \n    // Estimate mines in constrained area (rough approximation)\n    const estimatedConstrainedMines = Math.min(\n      remainingMines,\n      Math.round(constrainedCellCount * 0.2) // Assume ~20% mine density\n    );\n    \n    const remainingUnconstrainedMines = Math.max(\n      0,\n      remainingMines - estimatedConstrainedMines\n    );\n    \n    return Math.min(1, remainingUnconstrainedMines / unconstrainedCellCount);\n  }\n\n  /**\n   * Calculate information gain for revealing a specific cell\n   * Higher values indicate moves that provide more information\n   */\n  static calculateInformationGain(\n    coord: Coordinate,\n    gameBoard: GameBoard\n  ): number {\n    const adjacentCells = gameBoard.getAdjacentCells(coord.x, coord.y);\n    const unrevealedAdjacent = adjacentCells.filter(\n      (cell: Cell) => !cell.isRevealed && !cell.isFlagged\n    );\n    \n    // Information gain is roughly proportional to:\n    // 1. Number of unrevealed adjacent cells (more constraints created)\n    // 2. Number of existing adjacent constraints (more deductions possible)\n    const revealedAdjacent = adjacentCells.filter((cell: Cell) => cell.isRevealed);\n    \n    const baseGain = unrevealedAdjacent.length;\n    const constraintBonus = revealedAdjacent.length * 0.5;\n    \n    return baseGain + constraintBonus;\n  }\n\n  /**\n   * Find the cell with lowest mine probability\n   */\n  static findLowestRiskCell(\n    probabilities: Map<Coordinate, number>\n  ): Coordinate | null {\n    if (probabilities.size === 0) {\n      return null;\n    }\n\n    let lowestRisk: Coordinate | null = null;\n    let lowestProbability = 1;\n\n    probabilities.forEach((probability, coord) => {\n      if (probability < lowestProbability) {\n        lowestProbability = probability;\n        lowestRisk = coord;\n      }\n    });\n\n    return lowestRisk;\n  }\n\n  /**\n   * Handle edge cases in probability calculation\n   */\n  static handleEdgeCases(\n    gameBoard: GameBoard,\n    probabilities: Map<Coordinate, number>\n  ): Map<Coordinate, number> {\n    const adjustedProbabilities = new Map(probabilities);\n    \n    // Handle corner and edge cells (typically lower risk in early game)\n    const { width, height } = gameBoard.getDimensions();\n    const revealedCount = gameBoard.getRevealedCount();\n    \n    // Early game bonus for corners and edges\n    if (revealedCount < (width * height) * 0.1) {\n      adjustedProbabilities.forEach((prob, coord) => {\n        const isCorner = (coord.x === 0 || coord.x === width - 1) &&\n                        (coord.y === 0 || coord.y === height - 1);\n        const isEdge = coord.x === 0 || coord.x === width - 1 ||\n                      coord.y === 0 || coord.y === height - 1;\n        \n        if (isCorner) {\n          adjustedProbabilities.set(coord, prob * 0.8); // 20% bonus\n        } else if (isEdge) {\n          adjustedProbabilities.set(coord, prob * 0.9); // 10% bonus\n        }\n      });\n    }\n    \n    return adjustedProbabilities;\n  }\n\n  /**\n   * Helper: Convert coordinate to string for map operations\n   */\n  private static coordToString(coord: Coordinate): string {\n    return `${coord.x},${coord.y}`;\n  }\n\n\n}","import { Coordinate, HintAnalysis } from '../types/index';\nimport { GameBoard } from '../models/GameBoard';\nimport { ConstraintSolver } from './ConstraintSolver';\nimport { ProbabilityCalculator } from './ProbabilityCalculator';\n\n/**\n * Move recommendation with priority scoring\n */\ninterface MoveRecommendation {\n  coordinate: Coordinate;\n  probability: number;\n  priority: number;\n  reasoning: string;\n}\n\n/**\n * HintEngine provides intelligent move suggestions by integrating\n * constraint solving and probability analysis\n */\nexport class HintEngine {\n  /**\n   * Analyze the current board state and provide comprehensive hint analysis\n   */\n  static analyzeBoard(gameBoard: GameBoard): HintAnalysis {\n    // Find guaranteed moves using constraint solving\n    const guaranteedMoves = ConstraintSolver.findGuaranteedMoves(gameBoard);\n    \n    // Calculate probabilities for all unrevealed cells\n    const probabilities = ProbabilityCalculator.calculateProbabilities(gameBoard);\n    \n    // Apply edge case handling to probabilities\n    const adjustedProbabilities = ProbabilityCalculator.handleEdgeCases(\n      gameBoard,\n      probabilities\n    );\n    \n    // Find the best move recommendation\n    const recommendedMove = this.getBestMove(gameBoard, guaranteedMoves, adjustedProbabilities);\n    \n    // Calculate confidence based on available information\n    const confidence = this.calculateConfidence(guaranteedMoves, adjustedProbabilities);\n    \n    return {\n      guaranteedSafe: guaranteedMoves.safe,\n      guaranteedMines: guaranteedMoves.mines,\n      probabilities: adjustedProbabilities,\n      recommendedMove: recommendedMove?.coordinate || null,\n      confidence\n    };\n  }\n\n  /**\n   * Get the best move recommendation based on priority scoring\n   */\n  static getBestMove(\n    gameBoard: GameBoard,\n    guaranteedMoves: { safe: Coordinate[]; mines: Coordinate[] },\n    probabilities: Map<Coordinate, number>\n  ): MoveRecommendation | null {\n    // Priority 1: Guaranteed safe moves\n    if (guaranteedMoves.safe.length > 0) {\n      const bestSafe = this.selectBestGuaranteedSafe(gameBoard, guaranteedMoves.safe);\n      return {\n        coordinate: bestSafe,\n        probability: 0,\n        priority: 1000, // Highest priority\n        reasoning: 'Guaranteed safe move'\n      };\n    }\n\n    // Priority 2: Probabilistic moves\n    if (probabilities.size > 0) {\n      return this.selectBestProbabilisticMove(gameBoard, probabilities);\n    }\n\n    // No moves available\n    return null;\n  }\n\n  /**\n   * Select the best guaranteed safe move based on information gain\n   */\n  private static selectBestGuaranteedSafe(\n    gameBoard: GameBoard,\n    safeMoves: Coordinate[]\n  ): Coordinate {\n    if (safeMoves.length === 1) {\n      return safeMoves[0];\n    }\n\n    // Choose safe move with highest information gain\n    let bestMove = safeMoves[0];\n    let bestGain = ProbabilityCalculator.calculateInformationGain(bestMove, gameBoard);\n\n    for (let i = 1; i < safeMoves.length; i++) {\n      const gain = ProbabilityCalculator.calculateInformationGain(safeMoves[i], gameBoard);\n      if (gain > bestGain) {\n        bestGain = gain;\n        bestMove = safeMoves[i];\n      }\n    }\n\n    return bestMove;\n  }\n\n  /**\n   * Select the best probabilistic move using priority scoring\n   */\n  private static selectBestProbabilisticMove(\n    gameBoard: GameBoard,\n    probabilities: Map<Coordinate, number>\n  ): MoveRecommendation | null {\n    const recommendations: MoveRecommendation[] = [];\n\n    // Generate recommendations for all cells\n    probabilities.forEach((probability, coord) => {\n      const informationGain = ProbabilityCalculator.calculateInformationGain(coord, gameBoard);\n      const priority = this.calculateMovePriority(probability, informationGain);\n      \n      recommendations.push({\n        coordinate: coord,\n        probability,\n        priority,\n        reasoning: this.generateMoveReasoning(probability)\n      });\n    });\n\n    if (recommendations.length === 0) {\n      return null;\n    }\n\n    // Sort by priority (higher is better)\n    recommendations.sort((a, b) => b.priority - a.priority);\n    \n    return recommendations[0];\n  }\n\n  /**\n   * Calculate move priority based on probability and information gain\n   */\n  private static calculateMovePriority(\n    probability: number,\n    informationGain: number\n  ): number {\n    // Lower probability is better (safer move)\n    const safetyScore = (1 - probability) * 100;\n    \n    // Higher information gain is better\n    const informationScore = informationGain * 10;\n    \n    // Combine scores with safety being more important\n    return safetyScore * 0.7 + informationScore * 0.3;\n  }\n\n  /**\n   * Generate human-readable reasoning for move recommendation\n   */\n  private static generateMoveReasoning(\n    probability: number\n  ): string {\n    if (probability === 0) {\n      return 'Guaranteed safe move';\n    } else if (probability < 0.1) {\n      return `Very low risk (${Math.round(probability * 100)}% mine probability)`;\n    } else if (probability < 0.3) {\n      return `Low risk (${Math.round(probability * 100)}% mine probability)`;\n    } else if (probability < 0.5) {\n      return `Moderate risk (${Math.round(probability * 100)}% mine probability)`;\n    } else if (probability < 0.7) {\n      return `High risk (${Math.round(probability * 100)}% mine probability)`;\n    } else {\n      return `Very high risk (${Math.round(probability * 100)}% mine probability)`;\n    }\n  }\n\n  /**\n   * Calculate confidence level of the analysis\n   */\n  private static calculateConfidence(\n    guaranteedMoves: { safe: Coordinate[]; mines: Coordinate[] },\n    probabilities: Map<Coordinate, number>\n  ): number {\n    // High confidence if we have guaranteed moves\n    if (guaranteedMoves.safe.length > 0 || guaranteedMoves.mines.length > 0) {\n      return 0.9;\n    }\n\n    // Medium confidence if we have clear probability differences\n    if (probabilities.size > 0) {\n      const probs = Array.from(probabilities.values());\n      const minProb = Math.min(...probs);\n      const maxProb = Math.max(...probs);\n      \n      // Higher confidence when there's a clear best choice\n      const spread = maxProb - minProb;\n      if (spread > 0.3) {\n        return 0.7;\n      } else if (spread > 0.1) {\n        return 0.5;\n      } else {\n        return 0.3;\n      }\n    }\n\n    // Low confidence when no information available\n    return 0.1;\n  }\n\n  /**\n   * Get multiple move suggestions ranked by priority\n   */\n  static getTopMoves(\n    gameBoard: GameBoard,\n    count: number = 3\n  ): MoveRecommendation[] {\n    const guaranteedMoves = ConstraintSolver.findGuaranteedMoves(gameBoard);\n    const probabilities = ProbabilityCalculator.calculateProbabilities(gameBoard);\n    const adjustedProbabilities = ProbabilityCalculator.handleEdgeCases(\n      gameBoard,\n      probabilities\n    );\n\n    const recommendations: MoveRecommendation[] = [];\n\n    // Add guaranteed safe moves first\n    guaranteedMoves.safe.forEach(coord => {\n      recommendations.push({\n        coordinate: coord,\n        probability: 0,\n        priority: 1000,\n        reasoning: 'Guaranteed safe move'\n      });\n    });\n\n    // Add probabilistic moves\n    adjustedProbabilities.forEach((probability, coord) => {\n      const informationGain = ProbabilityCalculator.calculateInformationGain(coord, gameBoard);\n      const priority = this.calculateMovePriority(probability, informationGain);\n      \n      recommendations.push({\n        coordinate: coord,\n        probability,\n        priority,\n        reasoning: this.generateMoveReasoning(probability)\n      });\n    });\n\n    // Sort by priority and return top moves\n    recommendations.sort((a, b) => b.priority - a.priority);\n    return recommendations.slice(0, count);\n  }\n\n  /**\n   * Check if the current board state has any solvable moves\n   */\n  static hasSolvableMoves(gameBoard: GameBoard): boolean {\n    const guaranteedMoves = ConstraintSolver.findGuaranteedMoves(gameBoard);\n    return guaranteedMoves.safe.length > 0;\n  }\n\n  /**\n   * Get fallback move when no good options exist (lowest risk)\n   */\n  static getFallbackMove(gameBoard: GameBoard): Coordinate | null {\n    const probabilities = ProbabilityCalculator.calculateProbabilities(gameBoard);\n    \n    if (probabilities.size === 0) {\n      // No unrevealed cells\n      return null;\n    }\n\n    return ProbabilityCalculator.findLowestRiskCell(probabilities);\n  }\n\n  /**\n   * Validate that a suggested move is legal\n   */\n  static isValidMove(coord: Coordinate, gameBoard: GameBoard): boolean {\n    const cell = gameBoard.getCell(coord.x, coord.y);\n    return cell !== null && !cell.isRevealed && !cell.isFlagged;\n  }\n\n  /**\n   * Get detailed analysis for a specific cell\n   */\n  static analyzeCellRisk(\n    coord: Coordinate,\n    gameBoard: GameBoard\n  ): {\n    probability: number;\n    reasoning: string;\n    isGuaranteedSafe: boolean;\n    isGuaranteedMine: boolean;\n  } {\n    const guaranteedMoves = ConstraintSolver.findGuaranteedMoves(gameBoard);\n    const probabilities = ProbabilityCalculator.calculateProbabilities(gameBoard);\n    \n    const isGuaranteedSafe = guaranteedMoves.safe.some(\n      safe => safe.x === coord.x && safe.y === coord.y\n    );\n    const isGuaranteedMine = guaranteedMoves.mines.some(\n      mine => mine.x === coord.x && mine.y === coord.y\n    );\n    \n    const probability = probabilities.get(coord) || 0.5;\n    \n    let reasoning: string;\n    if (isGuaranteedSafe) {\n      reasoning = 'Guaranteed safe by constraint analysis';\n    } else if (isGuaranteedMine) {\n      reasoning = 'Guaranteed mine by constraint analysis';\n    } else {\n      reasoning = this.generateMoveReasoning(probability);\n    }\n    \n    return {\n      probability,\n      reasoning,\n      isGuaranteedSafe,\n      isGuaranteedMine\n    };\n  }\n}","import { Cell, Coordinate } from '../types/index';\n\n/**\n * GameBoard class manages the minesweeper grid state and operations\n */\nexport class GameBoard {\n  private board: Cell[][];\n  private width: number;\n  private height: number;\n  private mineCount: number;\n\n  constructor(width: number, height: number, mineCount: number) {\n    this.width = width;\n    this.height = height;\n    this.mineCount = mineCount;\n    this.board = this.initializeBoard();\n  }\n\n  /**\n   * Initialize empty board with all cells unrevealed and unflagged\n   */\n  private initializeBoard(): Cell[][] {\n    const board: Cell[][] = [];\n    \n    for (let y = 0; y < this.height; y++) {\n      board[y] = [];\n      for (let x = 0; x < this.width; x++) {\n        board[y][x] = {\n          hasMine: false,\n          isRevealed: false,\n          isFlagged: false,\n          adjacentMines: 0,\n          coordinates: { x, y }\n        };\n      }\n    }\n    \n    return board;\n  }\n\n  /**\n   * Get cell at specified coordinates\n   */\n  getCell(x: number, y: number): Cell | null {\n    if (!this.isValidCoordinate(x, y)) {\n      return null;\n    }\n    return this.board[y][x];\n  }\n\n  /**\n   * Get the entire board as a 2D array\n   */\n  getBoard(): Cell[][] {\n    return this.board;\n  }\n\n  /**\n   * Check if coordinates are within board boundaries\n   */\n  isValidCoordinate(x: number, y: number): boolean {\n    return x >= 0 && x < this.width && y >= 0 && y < this.height;\n  }\n\n  /**\n   * Get all adjacent cells to a given coordinate\n   */\n  getAdjacentCells(x: number, y: number): Cell[] {\n    const adjacent: Cell[] = [];\n    \n    for (let dy = -1; dy <= 1; dy++) {\n      for (let dx = -1; dx <= 1; dx++) {\n        if (dx === 0 && dy === 0) continue; // Skip center cell\n        \n        const adjX = x + dx;\n        const adjY = y + dy;\n        \n        if (this.isValidCoordinate(adjX, adjY)) {\n          adjacent.push(this.board[adjY][adjX]);\n        }\n      }\n    }\n    \n    return adjacent;\n  }\n\n  /**\n   * Get coordinates of all adjacent cells\n   */\n  getAdjacentCoordinates(x: number, y: number): Coordinate[] {\n    const adjacent: Coordinate[] = [];\n    \n    for (let dy = -1; dy <= 1; dy++) {\n      for (let dx = -1; dx <= 1; dx++) {\n        if (dx === 0 && dy === 0) continue; // Skip center cell\n        \n        const adjX = x + dx;\n        const adjY = y + dy;\n        \n        if (this.isValidCoordinate(adjX, adjY)) {\n          adjacent.push({ x: adjX, y: adjY });\n        }\n      }\n    }\n    \n    return adjacent;\n  }\n\n  /**\n   * Place mines on the board, avoiding the first click position\n   */\n  placeMines(minePositions: Coordinate[]): void {\n    // Clear any existing mines\n    this.clearMines();\n    \n    // Place mines at specified positions\n    for (const pos of minePositions) {\n      if (this.isValidCoordinate(pos.x, pos.y)) {\n        this.board[pos.y][pos.x].hasMine = true;\n      }\n    }\n    \n    // Calculate adjacent mine counts for all cells\n    this.calculateAdjacentMines();\n  }\n\n  /**\n   * Clear all mines from the board\n   */\n  private clearMines(): void {\n    for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n        this.board[y][x].hasMine = false;\n        this.board[y][x].adjacentMines = 0;\n      }\n    }\n  }\n\n  /**\n   * Calculate adjacent mine counts for all cells\n   */\n  private calculateAdjacentMines(): void {\n    for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n        if (!this.board[y][x].hasMine) {\n          const adjacentCells = this.getAdjacentCells(x, y);\n          this.board[y][x].adjacentMines = adjacentCells.filter(cell => cell.hasMine).length;\n        }\n      }\n    }\n  }\n\n  /**\n   * Reveal a cell at the specified coordinates\n   */\n  revealCell(x: number, y: number): boolean {\n    const cell = this.getCell(x, y);\n    if (!cell || cell.isRevealed || cell.isFlagged) {\n      return false;\n    }\n    \n    cell.isRevealed = true;\n    return true;\n  }\n\n  /**\n   * Toggle flag on a cell\n   */\n  toggleFlag(x: number, y: number): boolean {\n    const cell = this.getCell(x, y);\n    if (!cell || cell.isRevealed) {\n      return false;\n    }\n    \n    cell.isFlagged = !cell.isFlagged;\n    return true;\n  }\n\n  /**\n   * Get all unrevealed cells\n   */\n  getUnrevealedCells(): Cell[] {\n    const unrevealed: Cell[] = [];\n    \n    for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n        if (!this.board[y][x].isRevealed) {\n          unrevealed.push(this.board[y][x]);\n        }\n      }\n    }\n    \n    return unrevealed;\n  }\n\n  /**\n   * Get all revealed cells\n   */\n  getRevealedCells(): Cell[] {\n    const revealed: Cell[] = [];\n    \n    for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n        if (this.board[y][x].isRevealed) {\n          revealed.push(this.board[y][x]);\n        }\n      }\n    }\n    \n    return revealed;\n  }\n\n  /**\n   * Get all flagged cells\n   */\n  getFlaggedCells(): Cell[] {\n    const flagged: Cell[] = [];\n    \n    for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n        if (this.board[y][x].isFlagged) {\n          flagged.push(this.board[y][x]);\n        }\n      }\n    }\n    \n    return flagged;\n  }\n\n  /**\n   * Get all cells containing mines\n   */\n  getMineCells(): Cell[] {\n    const mines: Cell[] = [];\n    \n    for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n        if (this.board[y][x].hasMine) {\n          mines.push(this.board[y][x]);\n        }\n      }\n    }\n    \n    return mines;\n  }\n\n  /**\n   * Get all safe (non-mine) cells\n   */\n  getSafeCells(): Cell[] {\n    const safe: Cell[] = [];\n    \n    for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n        if (!this.board[y][x].hasMine) {\n          safe.push(this.board[y][x]);\n        }\n      }\n    }\n    \n    return safe;\n  }\n\n  /**\n   * Check if all safe cells are revealed (victory condition)\n   */\n  areAllSafeCellsRevealed(): boolean {\n    const safeCells = this.getSafeCells();\n    return safeCells.every(cell => cell.isRevealed);\n  }\n\n  /**\n   * Get board dimensions\n   */\n  getDimensions(): { width: number; height: number } {\n    return { width: this.width, height: this.height };\n  }\n\n  /**\n   * Get total mine count\n   */\n  getMineCount(): number {\n    return this.mineCount;\n  }\n\n  /**\n   * Get count of revealed cells\n   */\n  getRevealedCount(): number {\n    return this.getRevealedCells().length;\n  }\n\n  /**\n   * Get count of flagged cells\n   */\n  getFlaggedCount(): number {\n    return this.getFlaggedCells().length;\n  }\n\n  /**\n   * Reset board to initial state (keep dimensions and mine positions)\n   */\n  reset(): void {\n    for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n        this.board[y][x].isRevealed = false;\n        this.board[y][x].isFlagged = false;\n      }\n    }\n  }\n}","/**\n * Web Worker for AI calculations to prevent UI blocking\n * Requirements: 2.1, 2.2, 2.3, 2.4\n */\n\nimport { HintEngine } from '../ai/HintEngine';\nimport { GameBoard } from '../models/GameBoard';\nimport { Cell, HintAnalysis, Coordinate } from '../types/index';\n\n// Message types for worker communication\ninterface WorkerMessage {\n  id: string;\n  type: 'ANALYZE_BOARD' | 'CALCULATE_PROBABILITIES' | 'FIND_BEST_MOVE';\n  payload: any;\n}\n\ninterface WorkerResponse {\n  id: string;\n  type: 'ANALYSIS_COMPLETE' | 'ERROR' | 'WORKER_READY';\n  payload: any;\n}\n\n// Performance monitoring\ninterface PerformanceMetrics {\n  startTime: number;\n  endTime: number;\n  duration: number;\n  memoryUsage?: number;\n}\n\nclass AIWorker {\n  private performanceMetrics: Map<string, PerformanceMetrics> = new Map();\n\n  constructor() {\n    // Listen for messages from main thread\n    self.addEventListener('message', this.handleMessage.bind(this));\n    \n    // Send ready signal\n    this.postMessage({\n      id: 'init',\n      type: 'WORKER_READY',\n      payload: { timestamp: Date.now() }\n    });\n  }\n\n  private handleMessage(event: MessageEvent<WorkerMessage>): void {\n    const { id, type, payload } = event.data;\n    \n    try {\n      this.startPerformanceTracking(id);\n      \n      switch (type) {\n        case 'ANALYZE_BOARD':\n          this.analyzeBoardAsync(id, payload);\n          break;\n        case 'CALCULATE_PROBABILITIES':\n          this.calculateProbabilitiesAsync(id, payload);\n          break;\n        case 'FIND_BEST_MOVE':\n          this.findBestMoveAsync(id, payload);\n          break;\n        default:\n          this.postError(id, `Unknown message type: ${type}`);\n      }\n    } catch (error) {\n      this.postError(id, error instanceof Error ? error.message : 'Unknown error');\n    }\n  }\n\n  private async analyzeBoardAsync(id: string, payload: { boardData: Cell[][] }): Promise<void> {\n    try {\n      // Reconstruct GameBoard from serialized data\n      const gameBoard = this.reconstructGameBoard(payload.boardData);\n      \n      // Perform AI analysis\n      const analysis = await this.performAnalysisWithTimeout(gameBoard, 5000);\n      \n      this.endPerformanceTracking(id);\n      \n      // Send result back to main thread\n      this.postMessage({\n        id,\n        type: 'ANALYSIS_COMPLETE',\n        payload: {\n          analysis: this.serializeAnalysis(analysis),\n          performance: this.performanceMetrics.get(id)\n        }\n      });\n    } catch (error) {\n      this.postError(id, error instanceof Error ? error.message : 'Analysis failed');\n    }\n  }\n\n  private async calculateProbabilitiesAsync(id: string, payload: { boardData: Cell[][] }): Promise<void> {\n    try {\n      const gameBoard = this.reconstructGameBoard(payload.boardData);\n      \n      // Calculate probabilities only\n      const analysis = HintEngine.analyzeBoard(gameBoard);\n      const probabilities = this.serializeProbabilities(analysis.probabilities);\n      \n      this.endPerformanceTracking(id);\n      \n      this.postMessage({\n        id,\n        type: 'ANALYSIS_COMPLETE',\n        payload: {\n          probabilities,\n          performance: this.performanceMetrics.get(id)\n        }\n      });\n    } catch (error) {\n      this.postError(id, error instanceof Error ? error.message : 'Probability calculation failed');\n    }\n  }\n\n  private async findBestMoveAsync(id: string, payload: { boardData: Cell[][] }): Promise<void> {\n    try {\n      const gameBoard = this.reconstructGameBoard(payload.boardData);\n      \n      // Find best move only\n      const analysis = HintEngine.analyzeBoard(gameBoard);\n      \n      this.endPerformanceTracking(id);\n      \n      this.postMessage({\n        id,\n        type: 'ANALYSIS_COMPLETE',\n        payload: {\n          recommendedMove: analysis.recommendedMove,\n          confidence: analysis.confidence,\n          performance: this.performanceMetrics.get(id)\n        }\n      });\n    } catch (error) {\n      this.postError(id, error instanceof Error ? error.message : 'Best move calculation failed');\n    }\n  }\n\n  private async performAnalysisWithTimeout(gameBoard: GameBoard, timeoutMs: number): Promise<HintAnalysis> {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Analysis timeout'));\n      }, timeoutMs);\n\n      try {\n        const analysis = HintEngine.analyzeBoard(gameBoard);\n        clearTimeout(timeout);\n        resolve(analysis);\n      } catch (error) {\n        clearTimeout(timeout);\n        reject(error);\n      }\n    });\n  }\n\n  private reconstructGameBoard(boardData: Cell[][]): GameBoard {\n    // Create a new GameBoard instance from serialized data\n    const height = boardData.length;\n    const width = boardData[0]?.length || 0;\n    const mineCount = boardData.flat().filter(cell => cell.hasMine).length;\n    \n    const gameBoard = new GameBoard(width, height, mineCount);\n    \n    // Restore cell states\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const cellData = boardData[y][x];\n        const cell = gameBoard.getCell(x, y);\n        \n        if (cell) {\n          cell.hasMine = cellData.hasMine;\n          cell.isRevealed = cellData.isRevealed;\n          cell.isFlagged = cellData.isFlagged;\n          cell.adjacentMines = cellData.adjacentMines;\n        }\n      }\n    }\n    \n    return gameBoard;\n  }\n\n  private serializeAnalysis(analysis: HintAnalysis): any {\n    return {\n      guaranteedSafe: analysis.guaranteedSafe,\n      guaranteedMines: analysis.guaranteedMines,\n      probabilities: this.serializeProbabilities(analysis.probabilities),\n      recommendedMove: analysis.recommendedMove,\n      confidence: analysis.confidence\n    };\n  }\n\n  private serializeProbabilities(probabilities: Map<Coordinate, number>): Array<[Coordinate, number]> {\n    return Array.from(probabilities.entries());\n  }\n\n  private startPerformanceTracking(id: string): void {\n    const metrics: PerformanceMetrics = {\n      startTime: performance.now(),\n      endTime: 0,\n      duration: 0\n    };\n    \n    // Track memory usage if available\n    if ('memory' in performance) {\n      metrics.memoryUsage = (performance as any).memory.usedJSHeapSize;\n    }\n    \n    this.performanceMetrics.set(id, metrics);\n  }\n\n  private endPerformanceTracking(id: string): void {\n    const metrics = this.performanceMetrics.get(id);\n    if (metrics) {\n      metrics.endTime = performance.now();\n      metrics.duration = metrics.endTime - metrics.startTime;\n    }\n  }\n\n  private postMessage(response: WorkerResponse): void {\n    self.postMessage(response);\n  }\n\n  private postError(id: string, message: string): void {\n    this.endPerformanceTracking(id);\n    \n    this.postMessage({\n      id,\n      type: 'ERROR',\n      payload: {\n        error: message,\n        performance: this.performanceMetrics.get(id)\n      }\n    });\n  }\n}\n\n// Initialize worker\nnew AIWorker();\n\n// Export for TypeScript\nexport {};"],"names":["ConstraintSolver","gameBoard","constraints","revealedCells","cell","adjacentCells","unrevealedAdjacent","flaggedAdjacent","remainingMines","guaranteedSafe","constraint","coord","s","guaranteedMines","j","c1","c2","c1Set","c2Set","difference","mineDifference","str","x","y","set1","set2","item","ProbabilityCalculator","probabilities","unrevealedCells","constrainedCells","constrainedCoords","unconstrainedCoords","prob","unconstrainedProb","validAssignments","mineCounts","assignment","cellKey","isMine","probability","cells","cellKeys","totalCombinations","maxCombinations","i","mineCount","constrainedCellCount","unconstrainedCellCount","totalMines","flaggedCount","revealedMines","estimatedConstrainedMines","remainingUnconstrainedMines","revealedAdjacent","baseGain","constraintBonus","lowestRisk","lowestProbability","adjustedProbabilities","width","height","isCorner","isEdge","HintEngine","guaranteedMoves","recommendedMove","confidence","safeMoves","bestMove","bestGain","gain","recommendations","informationGain","priority","a","b","safetyScore","informationScore","probs","minProb","spread","count","isGuaranteedSafe","safe","isGuaranteedMine","mine","reasoning","GameBoard","__publicField","board","adjacent","dy","dx","adjX","adjY","minePositions","pos","unrevealed","revealed","flagged","mines","AIWorker","event","id","type","payload","error","analysis","timeoutMs","resolve","reject","timeout","boardData","_a","cellData","metrics","response","message"],"mappings":"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"}